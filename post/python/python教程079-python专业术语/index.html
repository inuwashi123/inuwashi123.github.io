<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Python教程079 Python专业术语 - None - 记录在日本从事IT的所感所想。</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="inuwashi" /><meta name="description" content="&amp;gt;&amp;gt;&amp;gt; 交互式终端中默认的 Python 提示符。解释器中以交互方式执行的代码示例会经常看到此提示。 &amp;hellip; 交互式终端中输入特殊代码行时默认的 Python 提示符，包括：缩进的代" /><meta name="keywords" content="日本IT, 程序开发, 运维保守" />






<meta name="generator" content="Hugo 0.57.2 with even 4.0.0" />


<link rel="canonical" href="https://inuwashi123.github.io/post/python/python%E6%95%99%E7%A8%8B079-python%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">


<link href="/dist/even.c2a46f00.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Python教程079 Python专业术语" />
<meta property="og:description" content="&gt;&gt;&gt; 交互式终端中默认的 Python 提示符。解释器中以交互方式执行的代码示例会经常看到此提示。 &hellip; 交互式终端中输入特殊代码行时默认的 Python 提示符，包括：缩进的代" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://inuwashi123.github.io/post/python/python%E6%95%99%E7%A8%8B079-python%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD/" />
<meta property="article:published_time" content="2019-12-12T09:09:44+09:00" />
<meta property="article:modified_time" content="2019-12-12T09:09:44+09:00" />
<meta itemprop="name" content="Python教程079 Python专业术语">
<meta itemprop="description" content="&gt;&gt;&gt; 交互式终端中默认的 Python 提示符。解释器中以交互方式执行的代码示例会经常看到此提示。 &hellip; 交互式终端中输入特殊代码行时默认的 Python 提示符，包括：缩进的代">


<meta itemprop="datePublished" content="2019-12-12T09:09:44&#43;09:00" />
<meta itemprop="dateModified" content="2019-12-12T09:09:44&#43;09:00" />
<meta itemprop="wordCount" content="13998">



<meta itemprop="keywords" content="python教程," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Python教程079 Python专业术语"/>
<meta name="twitter:description" content="&gt;&gt;&gt; 交互式终端中默认的 Python 提示符。解释器中以交互方式执行的代码示例会经常看到此提示。 &hellip; 交互式终端中输入特殊代码行时默认的 Python 提示符，包括：缩进的代"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">None</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">None</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Python教程079 Python专业术语</h1>

      <div class="post-meta">
        <span class="post-time"> 2019-12-12 </span>
        <div class="post-category">
            <a href="/categories/python/"> python </a>
            </div>
          <span class="more-meta"> 约 13998 字 </span>
          <span class="more-meta"> 预计阅读 28 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    
  </div>
</div>
    <div class="post-content">
      <p>&gt;&gt;&gt;<br />
交互式终端中默认的 Python 提示符。解释器中以交互方式执行的代码示例会经常看到此提示。</p>

<p>&hellip;<br />
交互式终端中输入特殊代码行时默认的 Python 提示符，包括：缩进的代码块，成对的分隔符之内（圆括号、方括号、花括号或三重引号），或是指定一个装饰器之后。</p>

<p>2to3<br />
一个将 Python 2.x 代码转换为 Python 3.x 代码的工具，能够处理大部分通过解析源码并遍历解析树可检测到的不兼容问题。
2to3 包含在标准库中，模块名为 lib2to3；并提供一个独立入口点 Tools/scripts/2to3。参见 2to3 - 自动将 Python 2 代码转为 Python 3 代码。</p>

<p>abstract base class &ndash; 抽象基类<br />
抽象基类简称 ABC，无法实例化，只能扩展的类。Python 通过 ABC 实现接口。除了继承 ABC 之外，类还 可以注册成为 ABC 的虚拟子类，声明自己实现了接口。是对 duck-typing 的补充，它提供了一种定义接口的新方式，相比之下其他技巧例如 hasattr() 显得过于笨拙或有微妙错误（例如使用 魔术方法）。ABC 引入了虚拟子类，这种类并非继承自其他类，但却仍能被 isinstance() 和 issubclass() 所认可；详见 abc 模块文档。Python 自带许多内置的 ABC 用于实现数据结构（在 collections.abc 模块中）、数字（在 numbers 模块中）、流（在 io 模块中）、导入查找器和加载器（在 importlib.abc 模块中）。你可以使用 abc 模块来创建自己的 ABC。</p>

<p>annotation &ndash; 标注<br />
关联到某个变量、类属性、函数形参或返回值的标签，被约定作为 type hint 来使用。</p>

<p>局部变量的标注在运行时不可访问，但全局变量、类属性和函数的标注会分别存放模块、类和函数的<strong>annotations</strong> 特殊属性中。</p>

<p>argument &ndash; 参数<br />
在调用函数时传给function（或 method ）的值。参数分为两种：</p>

<ol>
<li><p>关键字参数:<br />
在函数调用中前面带有标识符（例如 name=）或者作为包含在前面带有 ** 的字典里的值传入。举例来说，3 和 5 在以下对 complex() 的调用中均属于关键字参数:
complex(real=3, imag=5)
complex(**{&lsquo;real&rsquo;: 3, &lsquo;imag&rsquo;: 5})</p></li>

<li><p>位置参数:<br />
不属于关键字参数的参数。位置参数可出现于参数列表的开头以及作为前面带有 * 的 iterable 里的元素被传入。举例来说，3 和 5 在以下调用中均属于位置参数:<br />
complex(3, 5)<br />
complex(*(3, 5))<br />
参数会被赋值给函数体中对应的局部变量。根据语法，任何表达式都可用来表示一个参数；最终算出的值会被赋给对应的局部变量。</p></li>
</ol>

<p>asynchronous context manager &ndash; 异步上下文管理器<br />
此种对象通过定义<strong>aenter</strong>() 和<strong>aexit</strong>() 方法来对 async with 语句中的环境进行控制。由 PEP 492 引入。</p>

<p>asynchronous generator &ndash; 异步生成器<br />
返回值为 asynchronous generator iterator 的函数。它与使用 async def 定义的协程函数很相似，不同之处在于它包含 yield 表达式以产生一系列可在 async for 循环中使用的值。</p>

<p>此术语通常是指异步生成器函数，但在某些情况下则可能是指 异步生成器迭代器。如果需要清楚表达具体含义，请使用全称以避免歧义。</p>

<p>一个异步生成器函数可能包含 await 表达式或者 async for 以及 async with 语句。</p>

<p>asynchronous generator iterator &ndash; 异步生成器迭代器<br />
asynchronous generator 函数所创建的对象。此对象属于 asynchronous iterator，当使用<strong>anext</strong>() 方法调用时会返回一个可等待对象来执行异步生成器函数的代码直到下一个 yield 表达式。</p>

<p>每个 yield 会临时暂停处理，记住当前位置执行状态 (包括局部变量和挂起的 try 语句)。当该 异步生成器迭代器 与其他<strong>anext</strong>() 返回的可等待对象有效恢复时，它会从离开位置继续执行。参见 PEP 492 和 PEP 525。</p>

<p>asynchronous iterable &ndash; 异步可迭代对象<br />
可在 async for 语句中被使用的对象。必须通过它的<strong>aiter</strong>() 方法返回一个 asynchronous iterator。由 PEP 492 引入。</p>

<p>asynchronous iterator &ndash; 异步迭代器<br />
实现了<strong>aiter</strong>() 和<strong>anext</strong>() 方法的对象。<strong>anext</strong>必须返回一个 awaitable 对象。async for 会处理异步迭代器的 <strong>anext</strong>() 方法所返回的可等待对象，直到其引发一个 StopAsyncIteration 异常。由 PEP 492 引入。</p>

<p>attribute &ndash; 属性<br />
关联到一个对象的值，可以使用点号表达式通过其名称来引用。例如，如果一个对象 o 具有一个属性 a，就可以用 o.a 来引用它。在 Python 中，方法和数据属性（即 Java 术语中的“字段”）都是属性。方法也是属性，只不过恰好是可调用的对象（通常是函数，但也不一定）。</p>

<p>awaitable &ndash; 可等待对象<br />
能在 await 表达式中使用的对象。可以是 coroutine 或是具有 <strong>await</strong>() 方法的对象。参见 PEP 492。</p>

<p>BDFL<br />
“终身仁慈独裁者”的英文缩写，即 Guido van Rossum，Python 的创造者。</p>

<p>binary file &ndash; 二进制文件<br />
file object 能够读写 类字节对象。二进制文件的例子包括以二进制模式（&rsquo;rb&rsquo;, &lsquo;wb&rsquo; or &lsquo;rb+&lsquo;）打开的文件、sys.stdin.buffer、sys.stdout.buffer 以及 io.BytesIO 和 gzip.GzipFile 的实例。</p>

<p>另请参见 text file 了解能够读写 str 对象的文件对象。</p>

<p>bytes-like object &ndash; 字节类对象<br />
支持 缓冲协议 并且能导出 C-contiguous 缓冲的对象。这包括所有 bytes、bytearray 和 array.array 对象，以及许多普通 memoryview 对象。字节类对象可在多种二进制数据操作中使用；这些操作包括压缩、保存为二进制文件以及通过套接字发送等。</p>

<p>某些操作需要可变的二进制数据。这种对象在文档中常被称为“可读写字节类对象”。可变缓冲对象的例子包括 bytearray 以及 bytearray 的 memoryview。其他操作要求二进制数据存放于不可变对象 (&ldquo;只读字节类对象&rdquo;)；这种对象的例子包括 bytes 以及 bytes 对象的 memoryview。</p>

<p>bytecode &ndash; 字节码<br />
Python 源代码会被编译为字节码，即 CPython 解释器中表示 Python 程序的内部代码。字节码还会缓存在 .pyc 文件中，这样第二次执行同一文件时速度更快（可以免去将源码重新编译为字节码）。这种 &ldquo;中间语言&rdquo; 运行在根据字节码执行相应机器码的 virtual machine 之上。请注意不同 Python 虚拟机上的字节码不一定通用，也不一定能在不同 Python 版本上兼容。</p>

<p>字节码指令列表可以在 dis 模块 的文档中查看。</p>

<p>CamelCase &ndash; 驼峰式<br />
标识符的一种命名约定，单词的首字母大写，然后连接起来（例如，RefusedError）。PEP-8 建议类名使用驼峰式，但是 Python 标准库没有遵守这个建议。 参见蛇底式词条。</p>

<p>class &ndash; 类<br />
用来创建用户定义对象的模板。类定义通常包含对该类的实例进行操作的方法定义。</p>

<p>class variable &ndash; 类变量<br />
在类中定义的变量，并且仅限在类的层级上修改 (而不是在类的实例中修改)。</p>

<p>coercion &ndash; 强制类型转换<br />
在包含两个相同类型参数的操作中，一种类型的实例隐式地转换为另一种类型。例如，int(3.15) 是将原浮点数转换为整型数 3，但在 3+4.5 中，参数的类型不一致（一个是 int, 一个是 float），两者必须转换为相同类型才能相加，否则将引发 TypeError。如果没有强制类型转换机制，程序员必须将所有可兼容参数归一化为相同类型，例如要写成 float(3)+4.5 而不是 3+4.5。</p>

<p>complex number &ndash; 复数<br />
对普通实数系统的扩展，其中所有数字都被表示为一个实部和一个虚部的和。虚数是虚数单位（-1 的平方根）的实倍数，通常在数学中写为 i，在工程学中写为 j。Python 内置了对复数的支持，采用工程学标记方式；虚部带有一个 j 后缀，例如 3+1j。如果需要 math 模块内对象的对应复数版本，请使用 cmath，复数的使用是一个比较高级的数学特性。如果你感觉没有必要，忽略它们也几乎不会有任何问题。</p>

<p>container &ndash; 容器<br />
包含其他对象引用的对象。Python 中的大多数集合类型都是容器，不过有些不是。请与平坦序列相比较，这种序列是集合，但不是容器。</p>

<p>collectionr &ndash; 集合<br />
泛指由元素组成，可以单独访问各个元素的数据结构。有些集合可以包含任意类型的对象（参见容器词条），有些则只能包含一种原子类型的对象（参见平坦序列词条）。list 和 bytes 都是集合，只不过 list 是容器，而 bytes 是平坦序列。</p>

<p>context manager &ndash; 上下文管理器<br />
在 with 语句中使用，通过定义<strong>enter</strong>() 和<strong>exit</strong>()方法来控制环境状态的对象。参见 PEP 343。</p>

<p>contiguous &ndash; 连续<br />
一个缓冲如果是 C-连续 或 Fortran 连续 就会被认为是连续的。零维缓冲是 C 和 Fortran 连续的。在一维数组中，所有条目必须在内存中彼此相邻地排列，采用从零开始的递增索引顺序。在多维 C-连续数组中，当按内存地址排列时用最后一个索引访问条目时速度最快。但是在 Fortran 连续数组中则是用第一个索引最快。</p>

<p>coroutine &ndash; 协程<br />
协程是子例程的更一般形式。子例程可以在某一点进入并在另一点退出。协程则可以在许多不同的点上进入、退出和恢复。它们可通过 async def 语句来实现。参见 PEP 492。</p>

<p>coroutine function &ndash; 协程函数<br />
返回一个 coroutine 对象的函数。协程函数可通过 async def 语句来定义，并可能包含 await、async for 和 async with 关键字。这些特性是由 PEP 492 引入的。</p>

<p>CPython<br />
Python 编程语言的规范实现，在 python.org 上发布。&rdquo;CPython&rdquo; 一词用于在必要时将此实现与其他实现例如 Jython 或 IronPython 相区别。</p>

<p>decorator &ndash; 装饰器<br />
返回值为另一个函数的函数，通常使用 @wrapper 语法形式来进行函数变换。 装饰器的常见例子包括 classmethod() 和 staticmethod()。</p>

<p>装饰器语法只是一种语法糖，以下两个函数定义在语义上完全等价:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="o">...</span><span class="p">):</span>
    <span class="o">...</span>
<span class="n">f</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

<span class="nd">@staticmethod</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="o">...</span><span class="p">):</span>
    <span class="o">...</span></code></pre></td></tr></table>
</div>
</div>
<p>同的样概念也适用于类，但通常较少这样使用。</p>

<p>descriptor &ndash; 描述器<br />
任何定义了<strong>get</strong>(),__set__() 或<strong>delete</strong>() 方法的对象。当一个类属性为描述器时，它的特殊绑定行为就会在属性查找时被触发。通常情况下，使用 a.b 来获取、设置或删除一个属性时会在 a 的类字典中查找名称为 b 的对象，但如果 b 是一个描述器，则会调用对应的描述器方法。理解描述器的概念是更深层次理解 Python 的关键，因为这是许多重要特性的基础，包括函数、方法、属性、类方法、静态方法以及对超类的引用等等。</p>

<p>dictionary &ndash; 字典<br />
一个关联数组，其中的任意键都映射到相应的值。键可以是任何具有 <strong>hash</strong>() 和 <strong>eq</strong>() 方法的对象。在 Perl 语言中称为 hash。</p>

<p>dictionary view &ndash; 字典视图<br />
从 dict.keys(), dict.values() 和 dict.items() 返回的对象被称为字典视图。它们提供了字典条目的一个动态视图，这意味着当字典改变时，视图也会相应改变。要将字典视图强制转换为真正的列表，可使用 list(dictview)。参见 Dictionary view objects。</p>

<p>docstring &ndash; 文档字符串<br />
作为类、函数或模块之内的第一个表达式出现的字符串字面值。它在代码执行时会被忽略，但会被解释器识别并放入所在类、函数或模块的 <strong>doc</strong> 属性中。由于它可用于代码内省，因此是对象存放文档的规范位置。</p>

<p>duck-typing &ndash; 鸭子类型<br />
指一种编程风格，它并不依靠查找对象类型来确定其是否具有正确的接口，而是直接调用或使用其方法或属性（“看起来像鸭子，叫起来也像鸭子，那么肯定就是鸭子。”）由于强调接口而非特定类型，设计良好的代码可通过允许多态替代来提升灵活性。鸭子类型避免使用type() 或 isinstance() 检测。(但要注意鸭子类型可以使用 抽象基类 作为补充。) 而往往会采用 hasattr() 检测或是 EAFP 编程。</p>

<p>EAFP<br />
“求原谅比求许可更容易”的英文缩写。这种 Python 常用代码编写风格会假定所需的键或属性存在，并在假定错误时捕获异常。这种简洁快速风格的特定就是大量运用 try 和 except 语句。于其相对的则是所谓 LBYL 风格，常见于 C 等许多其他语言。</p>

<p>eager &ndash; 及早求值<br />
指可迭代对象一次构建好全部元素。在 Python 中，列表推导会及早求值。请与惰性 求值相比较。</p>

<p>expression &ndash; 表达式<br />
可以求出某个值的语法单元。 换句话说，一个表达式就是表达元素例如字面值、名称、属性访问、运算符或函数调用的汇总，它们最终都会返回一个值。 与许多其他语言不同，并非所有语言构件都是表达式。 还存在不能被用作表达式的 statement，例如 while。 赋值也是属于语句而非表达式。</p>

<p>extension module &ndash; 扩展模块<br />
以 C 或 C++ 编写的模块，使用 Python 的 C API 来与语言核心以及用户代码进行交互。</p>

<p>f-string &ndash; f-字符串<br />
带有 &lsquo;f&rsquo; 或 &lsquo;F&rsquo; 前缀的字符串字面值通常被称为“f-字符串”即 格式化字符串字面值 的简写。参见 PEP 498。</p>

<p>file object &ndash; 文件对象<br />
对外提供面向文件 API 以使用下层资源的对象（带有 read() 或 write() 这样的方法）。根据其创建方式的不同，文件对象可以处理对真实磁盘文件，对其他类型存储，或是对通讯设备的访问（例如标准输入/输出、内存缓冲区、套接字、管道等等）。文件对象也被称为 文件类对象 或 流。</p>

<p>实际上共有三种类别的文件对象: 原始 二进制文件, 缓冲 二进制文件 以及 文本文件。它们的接口定义均在 io 模块中。创建文件对象的规范方式是使用 open() 函数。</p>

<p>file-like object &ndash; 文件类对象<br />
file object 的同义词。</p>

<p>finder &ndash; 查找器<br />
一种会尝试查找被导入模块的 loader 的对象。</p>

<p>从 Python 3.3 起存在两种类型的查找器: 元路径查找器 配合 sys.meta_path 使用，以及 path entry finders 配合 sys.path_hooks 使用。更多详情可参见 PEP 302, PEP 420 和 PEP 451。</p>

<p>flat sequence &ndash; 平坦序列<br />
这种序列类型存储的是元素的值本身，而不是其他对象的引用。内置的类型中， str、bytes、bytearray、memoryview 和 array.array 是平坦序列；而list、tuple 和 collections.deque 是容器序列。参见容器词条。</p>

<p>floor division &ndash; 向下取整除法<br />
向下舍入到最接近的整数的数学除法。向下取整除法的运算符是 // 。例如，表达式 11 // 4 的计算结果是 2 ，而与之相反的是浮点数的真正除法返回 2.75 。注意 (-11) // 4 会返回 -3 因为这是 -2.75 向下 舍入得到的结果。见 PEP 238 。</p>

<p>function &ndash; 函数<br />
可以向调用者返回某个值的一组语句。还可以向其传入零个或多个 参数 并在函数体执行中被使用。另见 parameter, method 和 函数定义 等节。</p>

<p>function annotation &ndash; 函数标注<br />
即针对函数形参或返回值的 annotation 。</p>

<p>函数标注通常用于 类型提示：例如以下函数预期接受两个 int 参数并预期返回一个 int 值:
def sum_two_numbers(a: int, b: int) -&gt; int:
   return a + b
函数标注语法的详解见 函数定义 一节。</p>

<p>请参看 variable annotation 和 PEP 484 对此功能的描述。</p>

<p>__future__<br />
一种伪模块，可被程序员用来启用与当前解释器不兼容的新语言特性。</p>

<p>通过导入<strong>future</strong> 模块并对其中的变量求值，你可以查看新特性何时首次加入语言以及何时成为默认:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">__future__</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">__future__</span><span class="o">.</span><span class="n">division</span>
<span class="n">_Feature</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;alpha&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;alpha&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">8192</span><span class="p">)</span></code></pre></td></tr></table>
</div>
</div>
<p>garbage collection &ndash; 垃圾回收<br />
释放不再被使用的内存空间的过程。Python 是通过引用计数和一个能够检测和打破循环引用的循环垃圾回收器来执行垃圾回收的。可以使用 gc 模块来控制垃圾回收器。</p>

<p>generator &ndash; 生成器<br />
返回一个 generator iterator 的函数。它看起来很像普通函数，不同点在于其包含 yield 表达式以便产生一系列值供给 for-循环使用或是通过 next() 函数逐一获取。</p>

<p>通常是指生成器函数，但在某些情况下也可能是指 生成器迭代器。如果需要清楚表达具体含义，请使用全称以避免歧义。</p>

<p>generator iterator &ndash; 生成器迭代器<br />
generator 函数所创建的对象。</p>

<p>每个 yield 会临时暂停处理，记住当前位置执行状态（包括局部变量和挂起的 try 语句）。当该 生成器迭代器 恢复时，它会从离开位置继续执行（这与每次调用都从新开始的普通函数差别很大）。</p>

<p>generator expression &ndash; 生成器表达式<br />
返回一个迭代器的表达式。 它看起来很像普通表达式后面带有定义了一个循环变量、范围的 for 子句，以及一个可选的 if 子句。 以下复合表达式会为外层函数生成一系列值:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="nb">sum</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>         <span class="c1"># sum of squares 0, 1, 4, ... 81</span>
<span class="mi">285</span></code></pre></td></tr></table>
</div>
</div>
<p>generator function &ndash; 生成器函数<br />
定义体中有 yield 关键字的函数。调用生成器函数得到的是生成器。</p>

<p>generic function &ndash; 泛型函数<br />
为不同的类型实现相同操作的多个函数所组成的函数。在调用时会由调度算法来确定应该使用哪个实现。
另请参见 single dispatch 术语表条目、functools.singledispatch() 装饰器以及 PEP 443。</p>

<p>GIL<br />
参见 global interpreter lock。</p>

<p>global interpreter lock &ndash; 全局解释器锁<br />
CPython 解释器所采用的一种机制，它确保同一时刻只有一个线程在执行 Python bytecode。此机制通过设置对象模型（包括 dict 等重要内置类型）针对并发访问的隐式安全简化了 CPython 实现。给整个解释器加锁使得解释器多线程运行更方便，其代价则是牺牲了在多处理器上的并行性。</p>

<p>不过，某些标准库或第三方库的扩展模块被设计为在执行计算密集型任务如压缩或哈希时释放 GIL。此外，在执行 I/O 操作时也总是会释放 GIL。</p>

<p>创建一个（以更精细粒度来锁定共享数据的）“自由线程”解释器的努力从未获得成功，因为这会牺牲在普通单处理器情况下的性能。据信克服这种性能问题的措施将导致实现变得更复杂，从而更难以维护。</p>

<p>hash-based pyc &ndash; 基于哈希的 pyc<br />
使用对应源文件的哈希值而非最后修改时间来确定其有效性的字节码缓存文件。</p>

<p>hashable &ndash; 可哈希<br />
一个对象的哈希值如果在其生命周期内绝不改变，就被称为 可哈希 （它需要具有<strong>hash</strong>() 方法），并可以同其他对象进行比较（它需要具有<strong>eq</strong>() 方法）。可哈希对象必须具有相同的哈希值比较结果才会相同。</p>

<p>可哈希性使得对象能够作为字典键或集合成员使用，因为这些数据结构要在内部使用哈希值。</p>

<p>所有 Python 中的不可变内置对象都是可哈希的；可变容器（例如列表或字典）都不可哈希。用户定义类的实例对象默认是可哈希的。它们在比较时一定不相同（除非是与自己比较），它们的哈希值的生成基于其 id()。</p>

<p>IDLE<br />
Python 的 IDE，“集成开发与学习环境”的英文缩写。是 Python 标准发行版附带的基本编程器和解释器环境。</p>

<p>immutable &ndash; 不可变<br />
具有固定值的对象。不可变对象包括数字、字符串和元组。这样的对象不能被改变。如果必须存储一个不同的值，则必须创建新的对象。它们在需要常量哈希值的地方起着重要作用，例如作为字典中的键。</p>

<p>import path &ndash; 导入路径<br />
由多个位置（或 路径条目）组成的列表，会被模块的 path based finder 用来查找导入目标。在导入时，此位置列表通常来自 sys.path，但对次级包来说也可能来自上级包的 <strong>path</strong> 属性。</p>

<p>importing &ndash; 导入<br />
令一个模块中的 Python 代码能为另一个模块中的 Python 代码所使用的过程。</p>

<p>importer &ndash; 导入器<br />
查找并加载模块的对象；此对象既属于 finder 又属于 loader。</p>

<p>interactive &ndash; 交互<br />
Python 带有一个交互式解释器，即你可以在解释器提示符后输入语句和表达式，立即执行并查看其结果。只需不带参数地启动 python 命令（也可以在你的计算机开始菜单中选择相应菜单项）。在测试新想法或检验模块和包的时候用这种方式会非常方便（请记得使用 help(x)）。</p>

<p>interpreted &ndash; 解释型<br />
Python 一是种解释型语言，与之相对的是编译型语言，虽然两者的区别由于字节码编译器的存在而会有所模糊。这意味着源文件可以直接运行而不必显式地创建可执行文件再运行。解释型语言通常具有比编译型语言更短的开发/调试周期，但是其程序往往运行得更慢。参见 interactive。</p>

<p>interpreter shutdown &ndash; 解释器关闭<br />
当被要求关闭时，Python 解释器将进入一个特殊运行阶段并逐步释放所有已分配资源，例如模块和各种关键内部结构等。它还会多次调用 垃圾回收器。这会触发用户定义析构器或弱引用回调中的代码执行。在关闭阶段执行的代码可能会遇到各种异常，因为其所依赖的资源已不再有效（常见的例子有库模块或警告机制等）。</p>

<p>解释器需要关闭的主要原因有 <strong>main</strong> 模块或所运行的脚本已完成执行。</p>

<p>iterable &ndash; 可迭代对象<br />
能够逐一返回其成员项的对象。可迭代对象的例子包括所有序列类型（例如 list、str 和 tuple）以及某些非序列类型例如 dict、文件对象 以及定义了<strong>iter</strong>() 方法或是实现了 Sequence 语义的<strong>getitem</strong>() 方法的任意自定义类对象。</p>

<p>可迭代对象被可用于 for 循环以及许多其他需要一个序列的地方（zip()、map() &hellip;）。当一个可迭代对象作为参数传给内置函数 iter() 时，它会返回该对象的迭代器。这种迭代器适用于对值集合的一次性遍历。在使用可迭代对象时，你通常不需要调用 iter() 或者自己处理迭代器对象。for 语句会为你自动处理那些操作，创建一个临时的未命名变量用来在循环期间保存迭代器。参见 iterator、sequence 以及 generator。</p>

<p>iterator &ndash; 迭代器<br />
用来表示一连串数据流的对象。重复调用迭代器的<strong>next</strong>() 方法（或将其传给内置函数 next()）将逐个返回流中的项。当没有数据可用时则将引发 StopIteration 异常。到这时迭代器对象中的数据项已耗尽，继续调用其<strong>next</strong>() 方法只会再次引发 StopIteration 异常。迭代器必须具有<strong>iter</strong>() 方法用来返回该迭代器对象自身，因此迭代器必定也是可迭代对象，可被用于其他可迭代对象适用的大部分场合。一个显著的例外是那些会多次重复访问迭代项的代码。容器对象（例如 list）在你每次向其传入 iter() 函数或是在 for 循环中使用它时都会产生一个新的迭代器。如果在此情况下你尝试用迭代器则会返回在之前迭代过程中被耗尽的同一迭代器对象，使其看起来就像是一个空容器。</p>

<p>key function &ndash; 键函数<br />
键函数或称整理函数，是能够返回用于排序或排位的值的可调用对象。例如，locale.strxfrm() 可用于生成一个符合特定区域排序约定的排序键。</p>

<p>Python 中有许多工具都允许用键函数来控制元素的排位或分组方式。其中包括 min(), max(), sorted(), list.sort(), heapq.merge(), heapq.nsmallest(), heapq.nlargest() 以及 itertools.groupby()。</p>

<p>要创建一个键函数有多种方式。例如，str.lower() 方法可以用作忽略大小写排序的键函数。另外，键函数也可通过 lambda 表达式来创建，例如 lambda r: (r[0], r[2])。还有 operator 模块提供了三个键函数构造器：attrgetter()、itemgetter() 和 methodcaller()。请查看 如何排序 一节以获取创建和使用键函数的示例。</p>

<p>keyword argument &ndash; 关键字参数<br />
参见 argument。</p>

<p>lambda<br />
由一个单独 expression 构成的匿名内联函数，表达式会在调用时被求值。创建 lambda 函数的句法为 lambda [parameters]: expression</p>

<p>lazy &ndash; 惰性求值<br />
指可迭代的对象按需生成元素。在 Python 中，生成器会惰性求值。请与及早求值相 比较。</p>

<p>LBYL<br />
“先查看后跳跃”的英文缩写。这种代码编写风格会在进行调用或查找之前显式地检查前提条件。此风格与 EAFP 方式恰成对比，其特点是大量使用 if 语句。</p>

<p>在多线程环境中，LBYL 方式会导致“查看”和“跳跃”之间发生条件竞争风险。例如，以下代码 if key in mapping: return mapping[key] 可能由于在检查操作之后其他线程从 mapping 中移除了 key 而出错。这种问题可通过加锁或使用 EAFP 方式来解决。</p>

<p>list &ndash; 列表<br />
Python 内置的一种 sequence。虽然名为列表，但更类似于其他语言中的数组而非链接列表，因为访问元素的时间复杂度为 O(1)。</p>

<p>list comprehension &ndash; 列表推导式<br />
处理一个序列中的所有或部分元素并返回结果列表的一种紧凑写法。result = [&lsquo;{:#04x}&lsquo;.format(x) for x in range(256) if x % 2 == 0] 将生成一个 0 到 255 范围内的十六进制偶数对应字符串（0x..）的列表。其中 if 子句是可选的，如果省略则 range(256) 中的所有元素都会被处理。</p>

<p>loader &ndash; 加载器<br />
负责加载模块的对象。它必须定义名为 load_module() 的方法。加载器通常由一个 finder 返回。详情参见 PEP 302，对于 abstract base class 可参见 importlib.abc.Loader。</p>

<p>魔术方法<br />
一个非正式的同义词 special method 。</p>

<p>mapping &ndash; 映射<br />
一种支持任意键查找并实现了 Mapping 或 MutableMapping 抽象基类 中所规定方法的容器对象。 此类对象的例子包括 dict, collections.defaultdict, collections.OrderedDict 以及 collections.Counter。</p>

<p>meta path finder &ndash; 元路径查找器<br />
sys.meta_path 的搜索所返回的 finder。元路径查找器与 path entry finders 存在关联但并不相同。</p>

<p>请查看 importlib.abc.MetaPathFinder 了解元路径查找器所实现的方法。</p>

<p>metaclass &ndash; 元类<br />
一种用于创建类的类。类定义包含类名、类字典和基类列表。元类负责接受上述三个参数并创建相应的类。大部分面向对象的编程语言都会提供一个默认实现。Python 的特别之处在于可以创建自定义元类。大部分用户永远不需要这个工具，但当需要出现时，元类可提供强大而优雅的解决方案。它们已被用于记录属性访问日志、添加线程安全性、跟踪对象创建、实现单例，以及其他许多任务。</p>

<p>method &ndash; 方法<br />
在类内部定义的函数。如果作为该类的实例的一个属性来调用，方法将会获取实例对象作为其第一个 argument (通常命名为 self)。参见 function 和 nested scope。</p>

<p>method resolution order &ndash; 方法解析顺序<br />
方法解析顺序就是在查找成员时搜索全部基类所用的先后顺序。请查看 Python 2.3 方法解析顺序 了解自 2.3 版起 Python 解析器所用相关算法的详情。</p>

<p>module &ndash; 模块<br />
此对象是 Python 代码的一种组织单位。各模块具有独立的命名空间，可包含任意 Python 对象。模块可通过 importing 操作被加载到 Python 中。</p>

<p>module spec &ndash; 模块规格<br />
一个命名空间，其中包含用于加载模块的相关导入信息。是 importlib.machinery.ModuleSpec 的实例。</p>

<p>monkey patching &ndash; 猴子补丁<br />
在运行时动态修改模块、类或函数，通常是添加功能或修正缺陷。猴子补丁在内存中 发挥作用，不会修改源码，因此只对当前运行的程序实例有效。因为猴子补丁破坏了封 装，而且容易导致程序与补丁代码的实现细节紧密耦合，所以被视为临时的变通方案，不 是集成代码的推荐方式。</p>

<p>MRO
参见 method resolution order。</p>

<p>mutable &ndash; 可变<br />
可变对象可以在其 id() 保持固定的情况下改变其取值。另请参见 immutable。</p>

<p>name mangling &ndash; 名称改写<br />
Python 解释器在运行时自动把私有属性 <strong>x 重命名为 _MyClass</strong>x。</p>

<p>named tuple &ndash; 具名元组<br />
任何类似元组的类，其中的可索引元素也能使用名称属性来访问。（例如，time.localtime() 会返回一个类似元组的对象，其中的 year 既可以通过索引访问如 t[0] 也可以通过名称属性访问如 t.tm_year）。</p>

<p>具名元组可以是一个内置类型例如 time.struct_time，也可以通过正规的类定义来创建。一个完备的具名元组还可以通过工厂函数 collections.namedtuple() 来创建。后面这种方式会自动提供一些额外特性，例如 Employee(name=&lsquo;jones&rsquo;, title=&lsquo;programmer&rsquo;) 这样的自包含文档表示形式。</p>

<p>namespace &ndash; 命名空间<br />
命名空间是存放变量的场所。命名空间有局部、全局和内置的，还有对象中的嵌套命名空间（在方法之内）。命名空间通过防止命名冲突来支持模块化。例如，函数 builtins.open 与 os.open() 可通过各自的命名空间来区分。命名空间还通过明确哪个模块实现那个函数来帮助提高可读性和可维护性。例如，random.seed() 或 itertools.islice() 这种写法明确了这些函数是由 random 与 itertools 模块分别实现的。</p>

<p>namespace package &ndash; 命名空间包<br />
PEP 420 所引入的一种仅被用作子包的容器的 package，命名空间包可以没有实体表示物，其描述方式与 regular package 不同，因为它们没有<strong>init</strong>.py 文件。</p>

<p>nested scope &ndash; 嵌套作用域<br />
在一个定义范围内引用变量的能力。例如，在另一函数之内定义的函数可以引用前者的变量。请注意嵌套作用域默认只对引用有效而对赋值无效。局部变量的读写都受限于最内层作用域。类似的，全局变量的读写则作用于全局命名空间。通过 nonlocal 关键字可允许写入外层作用域。</p>

<p>new-style class &ndash; 新式类<br />
对于目前已被应于所有类对象的类形式的旧称谓。在早先的 Python 版本中，只有新式类能够使用 Python 新增的更灵活特性，例如 <strong>slots</strong>、描述符、特征属性、<strong>getattribute</strong>()、类方法和静态方法等。</p>

<p>object &ndash; 对象<br />
任何具有状态（属性或值）以及预定义行为（方法）的数据。object 也是任何 new-style class 的最顶层基类名。</p>

<p>package &ndash; 包<br />
一种可包含子模块或递归地包含子包的 Python module。从技术上说，包是带有<strong>path</strong> 属性的 Python 模块。</p>

<p>parameter &ndash; 形参<br />
function（或方法）定义中的命名实体，它指定函数可以接受的一个argument（或在某些情况下，多个实参）。有五种形参：</p>

<p>positional-or-keyword：位置或关键字，指定一个可以作为位置参数传入也可以作为 关键字参数 传入的实参。这是默认的形参类型，例如下面的 foo 和 bar:
def func(foo, bar=None): &hellip;</p>

<p>positional-only：仅限位置，指定一个只能按位置传入的参数。Python中没有定义仅限位置形参的语法。但是一些内置函数有仅限位置形参（比如 abs()）。</p>

<p>keyword-only：仅限关键字，指定一个只能通过关键字传入的参数。仅限关键字形参可通过在函数定义的形参列表中包含单个可变位置形参或者在多个可变位置形参之前放一个 * 来定义，例如下面的 kw_only1 和 kw_only2:
def func(arg, *, kw_only1, kw_only2): &hellip;</p>

<p>var-positional：可变位置，指定可以提供由一个任意数量的位置参数构成的序列（附加在其他形参已接受的位置参数之后）。这种形参可通过在形参名称前加缀 * 来定义，例如下面的args:
def func(*args, **kwargs): &hellip;</p>

<p>var-keyword：可变关键字，指定可以提供任意数量的关键字参数（附加在其他形参已接受的关键字参数之后）。这种形参可通过在形参名称前加缀 ** 来定义，例如上面的 kwargs。</p>

<p>形参可以同时指定可选和必选参数，也可以为某些可选参数指定默认值。</p>

<p>另参见 argument 术语表条目、参数与形参的区别 中的常见问题、inspect.Parameter 类、函数定义 一节以及 PEP 362。</p>

<p>path entry &ndash; 路径入口<br />
import path 中的一个单独位置，会被 path based finder 用来查找要导入的模块。</p>

<p>path entry finder &ndash; 路径入口查找器<br />
任一可调用对象使用 sys.path_hooks (即 path entry hook) 返回的 finder，此种对象能通过 path entry 来定位模块。</p>

<p>请参看 importlib.abc.PathEntryFinder 以了解路径入口查找器所实现的各个方法。</p>

<p>path entry hook &ndash; 路径入口钩子<br />
一种可调用对象，在知道如何查找特定 path entry 中的模块的情况下能够使用 sys.path_hook 列表返回一个 path entry finder。</p>

<p>path based finder &ndash; 基于路径的查找器<br />
默认的一种 元路径查找器，可在一个 import path 中查找模块。</p>

<p>path-like object &ndash; 路径类对象<br />
代表一个文件系统路径的对象。类路径对象可以是一个表示路径的 str 或者 bytes 对象，还可以是一个实现了 os.PathLike 协议的对象。一个支持 os.PathLike 协议的对象可通过调用 os.fspath() 函数转换为 str 或者 bytes 类型的文件系统路径；os.fsdecode() 和 os.fsencode() 可被分别用来确保获得 str 或 bytes 类型的结果。此对象是由 PEP 519 引入的。</p>

<p>PEP<br />
“Python 增强提议”的英文缩写。一个 PEP 就是一份设计文档，用来向 Python 社区提供信息，或描述一个 Python 的新增特性及其进度或环境。PEP 应当提供精确的技术规格和所提议特性的原理说明。</p>

<p>PEP 应被作为提出主要新特性建议、收集社区对特定问题反馈以及为必须加入 Python 的设计决策编写文档的首选机制。PEP 的作者有责任在社区内部建立共识，并应将不同意见也记入文档。</p>

<p>portion &ndash; 部分<br />
构成一个命名空间包的单个目录内文件集合（也可能存放于一个 zip 文件内），具体定义见 PEP 420。</p>

<p>positional argument &ndash; 位置参数<br />
参见 argument。</p>

<p>provisional API &ndash; 暂定 API<br />
暂定 API 是指被有意排除在标准库的向后兼容性保证之外的应用编程接口。虽然此类接口通常不会再有重大改变，但只要其被标记为暂定，就可能在核心开发者确定有必要的情况下进行向后不兼容的更改（甚至包括移除该接口）。此种更改并不会随意进行 &ndash; 仅在 API 被加入之前未考虑到的严重基础性缺陷被发现时才可能会这样做。</p>

<p>即便是对暂定 API 来说，向后不兼容的更改也会被视为“最后的解决方案” —— 任何问题被确认时都会尽可能先尝试找到一种向后兼容的解决方案。</p>

<p>这种处理过程允许标准库持续不断地演进，不至于被有问题的长期性设计缺陷所困。详情见 PEP 411。</p>

<p>provisional package &ndash; 暂定包<br />
参见 provisional API。</p>

<p>Python 3000<br />
Python 3.x 发布路线的昵称（这个名字在版本 3 的发布还遥遥无期的时候就已出现了）。有时也被缩写为“Py3k”。</p>

<p>Pythonic<br />
指一个思路或一段代码紧密遵循了 Python 语言最常用的风格和理念，而不是使用其他语言中通用的概念来实现代码。例如，Python 的常用风格是使用 for 语句循环来遍历一个可迭代对象中的所有元素。许多其他语言没有这样的结构，因此不熟悉 Python 的人有时会选择使用一个数字计数器:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">food</span><span class="p">)):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">food</span><span class="p">[</span><span class="n">i</span><span class="p">])</span></code></pre></td></tr></table>
</div>
</div>
<p>而相应的更简洁更 Pythonic 的方法是这样的:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="k">for</span> <span class="n">piece</span> <span class="ow">in</span> <span class="n">food</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">piece</span><span class="p">)</span></code></pre></td></tr></table>
</div>
</div>
<p>qualified name &ndash; 限定名称<br />
一个以点号分隔的名称，显示从模块的全局作用域到该模块中定义的某个类、函数或方法的“路径”，相关定义见 PEP 3155。对于最高层级的函数和类，限定名称与对象名称一致:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
<span class="o">...</span>     <span class="k">class</span> <span class="nc">D</span><span class="p">:</span>
<span class="o">...</span>         <span class="k">def</span> <span class="nf">meth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="o">...</span>             <span class="k">pass</span>
<span class="o">...</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">C</span><span class="o">.</span><span class="n">__qualname__</span>
<span class="s1">&#39;C&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">C</span><span class="o">.</span><span class="n">D</span><span class="o">.</span><span class="n">__qualname__</span>
<span class="s1">&#39;C.D&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">C</span><span class="o">.</span><span class="n">D</span><span class="o">.</span><span class="n">meth</span><span class="o">.</span><span class="n">__qualname__</span>
<span class="s1">&#39;C.D.meth&#39;</span></code></pre></td></tr></table>
</div>
</div>
<p>当被用于引用模块时，完整限定名称 意为标示该模块的以点号分隔的整个路径，其中包含其所有的父包，例如 email.mime.text:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">email.mime.text</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">email</span><span class="o">.</span><span class="n">mime</span><span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="vm">__name__</span>
<span class="s1">&#39;email.mime.text&#39;</span></code></pre></td></tr></table>
</div>
</div>
<p>reference count &ndash; 引用计数<br />
对特定对象的引用的数量。当一个对象的引用计数降为零时，所分配资源将被释放。引用计数对 Python 代码来说通常是不可见的，但它是 CPython 实现的一个关键元素。sys 模块定义了一个 getrefcount() 函数，程序员可调用它来返回特定对象的引用计数。
regular package &ndash; 正规包
传统型的 package，例如包含有一个<strong>init</strong>.py 文件的目录。</p>

<p>__slots__<br />
一种写在类内部的声明，通过预先声明实例属性等对象并移除实例字典来节省内存。虽然这种技巧很流行，但想要用好却并不容易，最好是只保留在少数情况下采用，例如极耗内存的应用程序，并且其中包含大量实例。</p>

<p>sequence &ndash; 序列<br />
一种 iterable，它支持通过<strong>getitem</strong>() 特殊方法来使用整数索引进行高效的元素访问，并定义了一个返回序列长度的<strong>len</strong>() 方法。内置的序列类型有 list、str、tuple 和 bytes。注意虽然 dict 也支持<strong>getitem</strong>() 和<strong>len</strong>()，但它被认为属于映射而非序列，因为它查找时使用任意的 immutable 键而非整数。</p>

<p>collections.abc.Sequence 抽象基类定义了一个更丰富的接口，它超越了<strong>getitem</strong>() 和<strong>len</strong>()，添加了 count(), index(),__contains__() 和<strong>reversed</strong>() 。 可以使用 register() 显式注册实现此扩展接口的类型。</p>

<p>single dispatch &ndash; 单分派<br />
一种 generic function 分派形式，其实现是基于单个参数的类型来选择的。</p>

<p>slice &ndash; 切片<br />
通常只包含了特定 sequence 的一部分的对象。切片是通过使用下标标记来创建的，在 [] 中给出几个以冒号分隔的数字，例如 variable_name[1:3:5]。方括号（下标）标记在内部使用 slice 对象。</p>

<p>snake_case &ndash; 蛇底式<br />
标识符的一种命名约定，使用下划线（_）连接单词，例如 run_until_complete。 PEP-8 把这种风格称为“使用下划线分隔的小写单词”，建议用于命名函数、方法、参数和 变量。PEP-8 建议包名直接把各个单词拼接起来，不使用分隔符。Python 标准库中有很多 使用蛇底式命名的标识符，不过也有单词之间没有分隔的标识符（例 如，getattr、classmethod、isinstance、str.endswith，等等）。参见驼峰式词条。</p>

<p>special method &ndash; 特殊方法<br />
一种由 Python 隐式调用的方法，用来对某个类型执行特定操作例如相加等等。这种方法的名称的首尾都为双下划线。特殊方法的文档参见 特殊方法名称。</p>

<p>statement &ndash; 语句<br />
语句是程序段（一个代码“块”）的组成单位。一条语句可以是一个expression或某个带有关键字的结构，例如 if、while 或 for。</p>

<p>struct sequence &ndash; 结构序列<br />
具有命名元素的元组。结构序列所暴露的接口类似于 named tuple，其元素既可通过索引也可作为属性来访问。不过，它们没有任何具名元组的方法，例如 _make() 或 _asdict()。结构序列的例子包括 sys.float_info 以及 os.stat() 的返回值。</p>

<p>text encoding &ndash; 文本编码<br />
用于将Unicode字符串编码为字节串的编码器。</p>

<p>text file &ndash; 文本文件<br />
一种能够读写 str 对象的 file object。通常一个文本文件实际是访问一个面向字节的数据流并自动处理 text encoding。文本文件的例子包括以文本模式（&rsquo;r&rsquo; 或 &lsquo;w&rsquo;）打开的文件、sys.stdin、sys.stdout 以及 io.StringIO 的实例。</p>

<p>triple-quoted string &ndash; 三引号字符串<br />
首尾各带三个连续双引号（&rdquo;）或者单引号（&rsquo;）的字符串。它们在功能上与首尾各用一个引号标注的字符串没有什么不同，但是有多种用处。它们允许你在字符串内包含未经转义的单引号和双引号，并且可以跨越多行而无需使用连接符，在编写文档字符串时特别好用。</p>

<p>type &ndash; 类型<br />
类型决定一个 Python 对象属于什么种类；每个对象都具有一种类型。要知道对象的类型，可以访问它的<strong>class</strong> 属性，或是通过 type(obj) 来获取。</p>

<p>type alias &ndash; 类型别名<br />
一个类型的同义词，创建方式是把类型赋值给特定的标识符。</p>

<p>类型别名的作用是简化 类型提示。例如:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span>

<span class="k">def</span> <span class="nf">remove_gray_shades</span><span class="p">(</span>
        <span class="n">colors</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
    <span class="k">pass</span></code></pre></td></tr></table>
</div>
</div>
<p>可以这样提高可读性:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span>

<span class="n">Color</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">remove_gray_shades</span><span class="p">(</span><span class="n">colors</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Color</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Color</span><span class="p">]:</span>
    <span class="k">pass</span></code></pre></td></tr></table>
</div>
</div>
<p>参见 typing 和 PEP 484，其中有对此功能的详细描述。</p>

<p>type hint &ndash; 类型提示<br />
annotation 为变量、类属性、函数的形参或返回值指定预期的类型。</p>

<p>类型提示属于可选项，Python 不要求提供，但其可对静态类型分析工具起作用，并可协助 IDE 实现代码补全与重构。</p>

<p>全局变量、类属性和函数的类型提示可以使用 typing.get_type_hints() 来访问，但局部变量则不可以。</p>

<p>参见 typing 和 PEP 484，其中有对此功能的详细描述。</p>

<p>universal newlines &ndash; 通用换行<br />
一种解读文本流的方式，将以下所有符号都识别为行结束标志：Unix 的行结束约定 &lsquo;\n&rsquo;、Windows 的约定 &lsquo;\r\n&rsquo; 以及旧版 Macintosh 的约定 &lsquo;\r&rsquo;。参见 PEP 278 和 PEP 3116 和 bytes.splitlines() 了解更多用法说明。</p>

<p>variable annotation &ndash; 变量标注<br />
对变量或类属性的 annotation。</p>

<p>在标注变量或类属性时，还可选择为其赋值:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="n">field</span><span class="p">:</span> <span class="s1">&#39;annotation&#39;</span></code></pre></td></tr></table>
</div>
</div>
<p>变量标注通常被用作 类型提示：例如以下变量预期接受 int 类型的值:
count: int = 0</p>

<p>virtual environment &ndash; 虚拟环境<br />
一种采用协作式隔离的运行时环境，允许 Python 用户和应用程序在安装和升级 Python 分发包时不会干扰到同一系统上运行的其他 Python 应用程序的行为。</p>

<p>virtual machine &ndash; 虚拟机<br />
一台完全通过软件定义的计算机。Python虚拟机可执行字节码编译器所生成的bytecode。</p>

<p>Zen of Python &ndash; Python 之禅<br />
列出 Python 设计的原则与哲学，有助于理解与使用这种语言。查看其具体内容可在交互模式提示符中输入 &ldquo;import this&rdquo;。</p>

<hr />

<p>转载请注明本网址。</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/python%E6%95%99%E7%A8%8B/">python教程</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/python/python%E6%95%99%E7%A8%8B080-%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Python教程080 读写文件</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/python/python%E6%95%99%E7%A8%8B078-pythonic%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E7%BC%96%E7%A8%8B/">
            <span class="next-text nav-default">Python教程078 Pythonic代码风格编程</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  
  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="https://github.com/inuwashi123" class="iconfont icon-github" title="github"></a>
  <a href="https://inuwashi123.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2019 - 
    2020
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">inuwashi</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
<script type="text/javascript" src="/dist/even.26188efa.min.js"></script>








</body>
</html>
